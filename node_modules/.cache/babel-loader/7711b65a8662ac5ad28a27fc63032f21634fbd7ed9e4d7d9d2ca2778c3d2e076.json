{"ast":null,"code":"var _jsxFileName = \"/home/thang/Documents/tmdt/ecommerce/frontend/src/context/CartContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useRef, useEffect } from \"react\";\nimport { useAuth } from \"./AuthContext\";\nimport * as cartApi from \"../services/Cart\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Debounce delay in ms\nconst DEBOUNCE_DELAY = 400;\nconst CartContext = /*#__PURE__*/createContext(undefined);\n\n// Helper: create empty cart\nconst emptyCart = () => ({\n  id: 0,\n  user_id: \"\",\n  items: [],\n  subtotal: 0,\n  total: 0\n});\n\n// Helper: recalculate cart totals from items\nconst recalculateCart = cart => {\n  const subtotal = cart.items.reduce((sum, item) => sum + item.unit_price * item.quantity, 0);\n  return {\n    ...cart,\n    subtotal,\n    total: subtotal // shipping is free\n  };\n};\nexport function CartProvider({\n  children\n}) {\n  _s();\n  const {\n    isLoggedIn,\n    isLoading: authLoading\n  } = useAuth();\n  const [cart, setCart] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Debounce timers for quantity updates\n  const debounceTimers = useRef(new Map());\n  // Pending quantity updates to sync\n  const pendingUpdates = useRef(new Map());\n\n  // Computed values\n  const itemCount = (cart === null || cart === void 0 ? void 0 : cart.items.reduce((sum, item) => sum + item.quantity, 0)) || 0;\n  const subtotal = (cart === null || cart === void 0 ? void 0 : cart.subtotal) || 0;\n  const total = (cart === null || cart === void 0 ? void 0 : cart.total) || 0;\n\n  // Phase 3: Hydrate cart from backend\n  const hydrateCart = useCallback(async () => {\n    if (!isLoggedIn) {\n      setCart(null);\n      return;\n    }\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await cartApi.getCart();\n      setCart(data);\n    } catch (err) {\n      var _err$response, _err$response$data;\n      console.error(\"Failed to hydrate cart:\", err);\n      setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.detail) || \"Failed to load cart\");\n      setCart(emptyCart());\n    } finally {\n      setLoading(false);\n    }\n  }, [isLoggedIn]);\n\n  // Hydrate on login\n  useEffect(() => {\n    if (!authLoading && isLoggedIn) {\n      hydrateCart();\n    } else if (!authLoading && !isLoggedIn) {\n      setCart(null);\n    }\n  }, [isLoggedIn, authLoading, hydrateCart]);\n\n  // Phase 4: Debounced sync to backend\n  const syncQuantityToBackend = useCallback((itemId, quantity) => {\n    // Clear existing timer\n    const existingTimer = debounceTimers.current.get(itemId);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Store pending update\n    pendingUpdates.current.set(itemId, quantity);\n\n    // Set new debounced timer\n    const timer = setTimeout(async () => {\n      const qty = pendingUpdates.current.get(itemId);\n      if (qty === undefined) return;\n      pendingUpdates.current.delete(itemId);\n      debounceTimers.current.delete(itemId);\n      try {\n        await cartApi.updateCartItem(itemId, qty);\n        // Don't update state - UI is already correct\n      } catch (err) {\n        console.error(\"Failed to sync quantity:\", err);\n        // On error, re-hydrate to get correct state\n        hydrateCart();\n      }\n    }, DEBOUNCE_DELAY);\n    debounceTimers.current.set(itemId, timer);\n  }, [hydrateCart]);\n\n  // Phase 1: Optimistic add to cart\n  const addToCart = useCallback(async (request, productInfo) => {\n    if (!cart) return;\n\n    // Check if item with same product + size exists\n    const existingItem = cart.items.find(item => item.product_id === request.product_id && item.product_size === request.size);\n    if (existingItem) {\n      // Optimistic: update quantity\n      const newQuantity = existingItem.quantity + request.quantity;\n      const updatedItems = cart.items.map(item => item.id === existingItem.id ? {\n        ...item,\n        quantity: newQuantity,\n        total_price: item.unit_price * newQuantity\n      } : item);\n      setCart(recalculateCart({\n        ...cart,\n        items: updatedItems\n      }));\n\n      // Sync to backend (debounced)\n      syncQuantityToBackend(existingItem.id, newQuantity);\n    } else {\n      // New item - need actual backend call to get the item ID\n      try {\n        const updatedCart = await cartApi.addToCart(request);\n        setCart(updatedCart);\n      } catch (err) {\n        var _err$response2, _err$response2$data;\n        console.error(\"Failed to add to cart:\", err);\n        setError(((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.detail) || \"Failed to add item\");\n      }\n    }\n  }, [cart, syncQuantityToBackend]);\n\n  // Phase 1: Optimistic update quantity\n  const updateQuantity = useCallback((itemId, quantity) => {\n    if (!cart || quantity < 1) return;\n\n    // Optimistic UI update immediately\n    const updatedItems = cart.items.map(item => item.id === itemId ? {\n      ...item,\n      quantity,\n      total_price: item.unit_price * quantity\n    } : item);\n    setCart(recalculateCart({\n      ...cart,\n      items: updatedItems\n    }));\n\n    // Debounced sync to backend\n    syncQuantityToBackend(itemId, quantity);\n  }, [cart, syncQuantityToBackend]);\n\n  // Phase 1: Optimistic remove item\n  const removeItem = useCallback(itemId => {\n    if (!cart) return;\n\n    // Cancel any pending update for this item\n    const timer = debounceTimers.current.get(itemId);\n    if (timer) {\n      clearTimeout(timer);\n      debounceTimers.current.delete(itemId);\n    }\n    pendingUpdates.current.delete(itemId);\n\n    // Optimistic UI update\n    const updatedItems = cart.items.filter(item => item.id !== itemId);\n    setCart(recalculateCart({\n      ...cart,\n      items: updatedItems\n    }));\n\n    // Async sync to backend\n    cartApi.removeFromCart(itemId).catch(err => {\n      console.error(\"Failed to remove item:\", err);\n      hydrateCart();\n    });\n  }, [cart, hydrateCart]);\n\n  // Clear cart (after checkout)\n  const clearCart = useCallback(() => {\n    setCart(emptyCart());\n    // Backend clear is handled by order creation\n  }, []);\n  return /*#__PURE__*/_jsxDEV(CartContext.Provider, {\n    value: {\n      cart,\n      loading,\n      error,\n      hydrateCart,\n      addToCart,\n      updateQuantity,\n      removeItem,\n      clearCart,\n      itemCount,\n      subtotal,\n      total\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 210,\n    columnNumber: 5\n  }, this);\n}\n_s(CartProvider, \"LoiDhtsWI3gZ8+sxkQDhJqmUSe0=\", false, function () {\n  return [useAuth];\n});\n_c = CartProvider;\nexport function useCart() {\n  _s2();\n  const context = useContext(CartContext);\n  if (context === undefined) {\n    throw new Error(\"useCart must be used within a CartProvider\");\n  }\n  return context;\n}\n_s2(useCart, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"CartProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","useAuth","cartApi","jsxDEV","_jsxDEV","DEBOUNCE_DELAY","CartContext","undefined","emptyCart","id","user_id","items","subtotal","total","recalculateCart","cart","reduce","sum","item","unit_price","quantity","CartProvider","children","_s","isLoggedIn","isLoading","authLoading","setCart","loading","setLoading","error","setError","debounceTimers","Map","pendingUpdates","itemCount","hydrateCart","data","getCart","err","_err$response","_err$response$data","console","response","detail","syncQuantityToBackend","itemId","existingTimer","current","get","clearTimeout","set","timer","setTimeout","qty","delete","updateCartItem","addToCart","request","productInfo","existingItem","find","product_id","product_size","size","newQuantity","updatedItems","map","total_price","updatedCart","_err$response2","_err$response2$data","updateQuantity","removeItem","filter","removeFromCart","catch","clearCart","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useCart","_s2","context","Error","$RefreshReg$"],"sources":["/home/thang/Documents/tmdt/ecommerce/frontend/src/context/CartContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from \"react\";\nimport { useAuth } from \"./AuthContext\";\nimport * as cartApi from \"../services/Cart\";\nimport { ICart, IAddToCartRequest } from \"../services/Cart\";\n\n// Debounce delay in ms\nconst DEBOUNCE_DELAY = 400;\n\ninterface CartContextType {\n  cart: ICart | null;\n  loading: boolean;\n  error: string | null;\n  // Hydrate cart from backend (on login/refresh)\n  hydrateCart: () => Promise<void>;\n  // Optimistic add to cart\n  addToCart: (request: IAddToCartRequest, productInfo: { name: string; image: string; slug: string }) => Promise<void>;\n  // Optimistic update quantity\n  updateQuantity: (itemId: number, quantity: number) => void;\n  // Optimistic remove item\n  removeItem: (itemId: number) => void;\n  // Clear cart (after checkout)\n  clearCart: () => void;\n  // Cart computed values\n  itemCount: number;\n  subtotal: number;\n  total: number;\n}\n\nconst CartContext = createContext<CartContextType | undefined>(undefined);\n\n// Helper: create empty cart\nconst emptyCart = (): ICart => ({\n  id: 0,\n  user_id: \"\",\n  items: [],\n  subtotal: 0,\n  total: 0,\n});\n\n// Helper: recalculate cart totals from items\nconst recalculateCart = (cart: ICart): ICart => {\n  const subtotal = cart.items.reduce((sum, item) => sum + item.unit_price * item.quantity, 0);\n  return {\n    ...cart,\n    subtotal,\n    total: subtotal, // shipping is free\n  };\n};\n\nexport function CartProvider({ children }: { children: React.ReactNode }) {\n  const { isLoggedIn, isLoading: authLoading } = useAuth();\n  const [cart, setCart] = useState<ICart | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Debounce timers for quantity updates\n  const debounceTimers = useRef<Map<number, NodeJS.Timeout>>(new Map());\n  // Pending quantity updates to sync\n  const pendingUpdates = useRef<Map<number, number>>(new Map());\n\n  // Computed values\n  const itemCount = cart?.items.reduce((sum, item) => sum + item.quantity, 0) || 0;\n  const subtotal = cart?.subtotal || 0;\n  const total = cart?.total || 0;\n\n  // Phase 3: Hydrate cart from backend\n  const hydrateCart = useCallback(async () => {\n    if (!isLoggedIn) {\n      setCart(null);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await cartApi.getCart();\n      setCart(data);\n    } catch (err: any) {\n      console.error(\"Failed to hydrate cart:\", err);\n      setError(err.response?.data?.detail || \"Failed to load cart\");\n      setCart(emptyCart());\n    } finally {\n      setLoading(false);\n    }\n  }, [isLoggedIn]);\n\n  // Hydrate on login\n  useEffect(() => {\n    if (!authLoading && isLoggedIn) {\n      hydrateCart();\n    } else if (!authLoading && !isLoggedIn) {\n      setCart(null);\n    }\n  }, [isLoggedIn, authLoading, hydrateCart]);\n\n  // Phase 4: Debounced sync to backend\n  const syncQuantityToBackend = useCallback((itemId: number, quantity: number) => {\n    // Clear existing timer\n    const existingTimer = debounceTimers.current.get(itemId);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Store pending update\n    pendingUpdates.current.set(itemId, quantity);\n\n    // Set new debounced timer\n    const timer = setTimeout(async () => {\n      const qty = pendingUpdates.current.get(itemId);\n      if (qty === undefined) return;\n\n      pendingUpdates.current.delete(itemId);\n      debounceTimers.current.delete(itemId);\n\n      try {\n        await cartApi.updateCartItem(itemId, qty);\n        // Don't update state - UI is already correct\n      } catch (err: any) {\n        console.error(\"Failed to sync quantity:\", err);\n        // On error, re-hydrate to get correct state\n        hydrateCart();\n      }\n    }, DEBOUNCE_DELAY);\n\n    debounceTimers.current.set(itemId, timer);\n  }, [hydrateCart]);\n\n  // Phase 1: Optimistic add to cart\n  const addToCart = useCallback(async (\n    request: IAddToCartRequest,\n    productInfo: { name: string; image: string; slug: string }\n  ) => {\n    if (!cart) return;\n\n    // Check if item with same product + size exists\n    const existingItem = cart.items.find(\n      (item) => item.product_id === request.product_id && item.product_size === request.size\n    );\n\n    if (existingItem) {\n      // Optimistic: update quantity\n      const newQuantity = existingItem.quantity + request.quantity;\n      const updatedItems = cart.items.map((item) =>\n        item.id === existingItem.id\n          ? { ...item, quantity: newQuantity, total_price: item.unit_price * newQuantity }\n          : item\n      );\n      setCart(recalculateCart({ ...cart, items: updatedItems }));\n\n      // Sync to backend (debounced)\n      syncQuantityToBackend(existingItem.id, newQuantity);\n    } else {\n      // New item - need actual backend call to get the item ID\n      try {\n        const updatedCart = await cartApi.addToCart(request);\n        setCart(updatedCart);\n      } catch (err: any) {\n        console.error(\"Failed to add to cart:\", err);\n        setError(err.response?.data?.detail || \"Failed to add item\");\n      }\n    }\n  }, [cart, syncQuantityToBackend]);\n\n  // Phase 1: Optimistic update quantity\n  const updateQuantity = useCallback((itemId: number, quantity: number) => {\n    if (!cart || quantity < 1) return;\n\n    // Optimistic UI update immediately\n    const updatedItems = cart.items.map((item) =>\n      item.id === itemId\n        ? { ...item, quantity, total_price: item.unit_price * quantity }\n        : item\n    );\n    setCart(recalculateCart({ ...cart, items: updatedItems }));\n\n    // Debounced sync to backend\n    syncQuantityToBackend(itemId, quantity);\n  }, [cart, syncQuantityToBackend]);\n\n  // Phase 1: Optimistic remove item\n  const removeItem = useCallback((itemId: number) => {\n    if (!cart) return;\n\n    // Cancel any pending update for this item\n    const timer = debounceTimers.current.get(itemId);\n    if (timer) {\n      clearTimeout(timer);\n      debounceTimers.current.delete(itemId);\n    }\n    pendingUpdates.current.delete(itemId);\n\n    // Optimistic UI update\n    const updatedItems = cart.items.filter((item) => item.id !== itemId);\n    setCart(recalculateCart({ ...cart, items: updatedItems }));\n\n    // Async sync to backend\n    cartApi.removeFromCart(itemId).catch((err) => {\n      console.error(\"Failed to remove item:\", err);\n      hydrateCart();\n    });\n  }, [cart, hydrateCart]);\n\n  // Clear cart (after checkout)\n  const clearCart = useCallback(() => {\n    setCart(emptyCart());\n    // Backend clear is handled by order creation\n  }, []);\n\n  return (\n    <CartContext.Provider\n      value={{\n        cart,\n        loading,\n        error,\n        hydrateCart,\n        addToCart,\n        updateQuantity,\n        removeItem,\n        clearCart,\n        itemCount,\n        subtotal,\n        total,\n      }}\n    >\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nexport function useCart() {\n  const context = useContext(CartContext);\n  if (context === undefined) {\n    throw new Error(\"useCart must be used within a CartProvider\");\n  }\n  return context;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}