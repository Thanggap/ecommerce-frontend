{"ast":null,"code":"import { BACKEND_URL } from \"../constants\";\n\n/**\n * Elasticsearch search interface\n */\n\n/**\n * Search products using Elasticsearch\n * Falls back to regular API if ES is unavailable\n */\nexport const searchProducts = async (filters = {}) => {\n  try {\n    const params = new URLSearchParams();\n    if (filters.q) params.append(\"q\", filters.q);\n    if (filters.page !== undefined) params.append(\"page\", filters.page.toString());\n    if (filters.limit !== undefined) params.append(\"limit\", filters.limit.toString());\n    if (filters.product_type) params.append(\"product_type\", filters.product_type);\n    if (filters.min_price !== undefined) params.append(\"min_price\", filters.min_price.toString());\n    if (filters.max_price !== undefined) params.append(\"max_price\", filters.max_price.toString());\n    if (filters.on_sale) params.append(\"on_sale\", \"true\");\n    if (filters.sort) params.append(\"sort\", filters.sort);\n    const response = await fetch(`${BACKEND_URL}/search/products?${params.toString()}`);\n    if (response.ok) {\n      return await response.json();\n    } else {\n      console.error(\"Search API failed:\", response.status);\n      return null;\n    }\n  } catch (err) {\n    console.error(\"Error searching products:\", err);\n    return null;\n  }\n};\n\n/**\n * Get autocomplete suggestions\n */\nexport const getAutocompleteSuggestions = async query => {\n  if (!query || query.length < 2) return null;\n  try {\n    const response = await fetch(`${BACKEND_URL}/search/autocomplete?q=${encodeURIComponent(query)}`);\n    if (response.ok) {\n      return await response.json();\n    } else {\n      return null;\n    }\n  } catch (err) {\n    console.error(\"Error fetching autocomplete:\", err);\n    return null;\n  }\n};\n\n/**\n * Get search aggregations (facets)\n */\nexport const getSearchAggregations = async () => {\n  try {\n    const response = await fetch(`${BACKEND_URL}/search/aggregations`);\n    if (response.ok) {\n      return await response.json();\n    } else {\n      return null;\n    }\n  } catch (err) {\n    console.error(\"Error fetching aggregations:\", err);\n    return null;\n  }\n};\n\n/**\n * Check Elasticsearch health\n */\nexport const checkSearchHealth = async () => {\n  try {\n    const response = await fetch(`${BACKEND_URL}/search/health`);\n    if (response.ok) {\n      const data = await response.json();\n      return data.status !== \"unavailable\";\n    }\n    return false;\n  } catch (err) {\n    return false;\n  }\n};","map":{"version":3,"names":["BACKEND_URL","searchProducts","filters","params","URLSearchParams","q","append","page","undefined","toString","limit","product_type","min_price","max_price","on_sale","sort","response","fetch","ok","json","console","error","status","err","getAutocompleteSuggestions","query","length","encodeURIComponent","getSearchAggregations","checkSearchHealth","data"],"sources":["/home/thang/Documents/tmdt/ecommerce/frontend/src/services/Search.ts"],"sourcesContent":["import { BACKEND_URL } from \"../constants\";\n\n/**\n * Elasticsearch search interface\n */\nexport interface ISearchFilters {\n  q?: string; // Search query\n  page?: number;\n  limit?: number;\n  product_type?: string;\n  min_price?: number;\n  max_price?: number;\n  on_sale?: boolean;\n  sort?: \"relevance\" | \"price_asc\" | \"price_desc\" | \"newest\";\n}\n\nexport interface ISearchResult {\n  items: any[];\n  total: number;\n  page: number;\n  limit: number;\n  total_pages: number;\n  query?: string;\n  took_ms: number;\n}\n\nexport interface IAutocompleteResult {\n  suggestions: Array<{\n    name: string;\n    type: string;\n  }>;\n}\n\n/**\n * Search products using Elasticsearch\n * Falls back to regular API if ES is unavailable\n */\nexport const searchProducts = async (\n  filters: ISearchFilters = {}\n): Promise<ISearchResult | null> => {\n  try {\n    const params = new URLSearchParams();\n\n    if (filters.q) params.append(\"q\", filters.q);\n    if (filters.page !== undefined) params.append(\"page\", filters.page.toString());\n    if (filters.limit !== undefined) params.append(\"limit\", filters.limit.toString());\n    if (filters.product_type) params.append(\"product_type\", filters.product_type);\n    if (filters.min_price !== undefined)\n      params.append(\"min_price\", filters.min_price.toString());\n    if (filters.max_price !== undefined)\n      params.append(\"max_price\", filters.max_price.toString());\n    if (filters.on_sale) params.append(\"on_sale\", \"true\");\n    if (filters.sort) params.append(\"sort\", filters.sort);\n\n    const response = await fetch(`${BACKEND_URL}/search/products?${params.toString()}`);\n\n    if (response.ok) {\n      return await response.json();\n    } else {\n      console.error(\"Search API failed:\", response.status);\n      return null;\n    }\n  } catch (err) {\n    console.error(\"Error searching products:\", err);\n    return null;\n  }\n};\n\n/**\n * Get autocomplete suggestions\n */\nexport const getAutocompleteSuggestions = async (\n  query: string\n): Promise<IAutocompleteResult | null> => {\n  if (!query || query.length < 2) return null;\n\n  try {\n    const response = await fetch(\n      `${BACKEND_URL}/search/autocomplete?q=${encodeURIComponent(query)}`\n    );\n\n    if (response.ok) {\n      return await response.json();\n    } else {\n      return null;\n    }\n  } catch (err) {\n    console.error(\"Error fetching autocomplete:\", err);\n    return null;\n  }\n};\n\n/**\n * Get search aggregations (facets)\n */\nexport const getSearchAggregations = async (): Promise<any | null> => {\n  try {\n    const response = await fetch(`${BACKEND_URL}/search/aggregations`);\n\n    if (response.ok) {\n      return await response.json();\n    } else {\n      return null;\n    }\n  } catch (err) {\n    console.error(\"Error fetching aggregations:\", err);\n    return null;\n  }\n};\n\n/**\n * Check Elasticsearch health\n */\nexport const checkSearchHealth = async (): Promise<boolean> => {\n  try {\n    const response = await fetch(`${BACKEND_URL}/search/health`);\n    if (response.ok) {\n      const data = await response.json();\n      return data.status !== \"unavailable\";\n    }\n    return false;\n  } catch (err) {\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}